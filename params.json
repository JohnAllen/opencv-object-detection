{
  "name": "OpenCV-object-detection-tutorial",
  "tagline": "Tutorial on how to detect objects using OpenCV, including a negative image set",
  "body": "# Object Detection Using OpenCV\r\n\r\nRecently I wanted to create object detection capabilities for a robot I am working on that will detect electrical outlets and plug itself in.  The robot needs to perform with a high level of accuracy and success, at least 99% or more each step of the way.  One thing to remember about robot operations is that if each step required to complete a goal succeeds only 99% of the time and there are multiple processes, the ultimate-goal success rate will be .99^n, which could result in ultimate-goal completion rate that is significantly less than 99%.  So each step of the way must be nearly >99% successful.  Object detection is the first step in many robotic operations and is a step that subsequent steps depend on.  \r\n\r\nBecause the performance of the object detection directly affects the performance of the robots using it, I chose to take the time to understand how OpenCV’s object detection works and how to optimize its performance.  I also found the available documentation, tutorials incomplete or outdated; and a few SO questions similar to mine remain unanswered.  So it seemed that taking the time to write a detailed reference with my findings might benefit others.\r\n\r\nHere's a great example of how well OpenCV's object detection can work when you get it right!!\r\n\r\n![](images/outlet-detection-10-ines.PNG)\r\n\r\nIn this post, I use *nix programs; I apologize to Windows users in advance.  \r\n\r\nI want to point out that installing OpenCV for certain platforms can be complicated and slow.  I suggest reading this post thoroughly, collect your images and then install OpenCV on a remote server.  Installation will be much easier if you use a remote server running Ubuntu and you can rent a server with much more CPU than your laptop will have.\r\n\r\nAs I began to learn about OpenCV’s object detection capabilities, I had numerous questions:\r\n\r\n* What is going on behind the scenes?  How does the Viola-Jones algorithm work?\r\n* How many positive and negative images do I need?  \r\n* Should I provide multiple positive images or will using OpenCV’s `create_samples` utility to generate distorted versions    of a single positive image suffice?\r\n* Does it matter what the negative images contain so long as they don’t contain the object I want to detect?\r\n* For positive images, do the objects need to fill the entire image?\r\n* What is the easiest way to create positive images? How can I acquire a negative image set?\r\n* Do the positive and negative images need to be the same size?\r\n* Which options do I want to pass to each of the OpenCV programs?\r\n* How can I quickly test the performance of my classifier and cascade file?\r\n* How could I train my classifier on a remote host so I don’t have to use my machine to train for multiple days or weeks?\r\n* Does it matter if I use Haar-features or can I use linear binary patterns (LBP) since the LBP approach is faster?\r\n\r\n## Viola-Jones Algorithm - Features, Integral Images and Rectangular Boxes\r\n\r\nFirst off, let’s briefly delve into how the Viola-Jones algorithm works and try and understand what it’s doing.  If one reads the abstract to the original Viola-Jones paper, we find some new but important terms: integral image, cascade, classifier, feature, etc.  Let’s take a minute to learn about them here.\r\n\r\nHow does this software use rectangular boxes to detect objects?  What the are integral images?\r\n\r\nIntegral images and rectangular boxes are the building blocks that the Viola-Jones algorithm uses to detect features.  An object’s features are seen by the computer as differences in pixel intensities between different parts of images.  The algorithm doesn’t care what color our objects and images are, just the relative darkness between parts of the images.  \r\n\r\nThe original paper uses the most obvious feature of human faces, the difference in darkness between the human eye and cheek regions.  The training program looks at all combinations of adjacent rectangles as sub-images within each training image and compares the difference between adjacent rectangles.\r\n\r\nA simplification that could help us understand how object features are detected is to reduce the image to how the computer sees it.  Computers don’t see images, they see numbers.  In this case, the algorithm determines the darkness of adjacent rectangles and compares those.  Individual features are differences in the darkness of adjacent rectangles.\r\n\r\n\r\n## Steps Required to Create an Object Detection Cascade File\r\n\r\nBelow is a brief overview of the steps required to generate a cascade file for object detection.  Don’t worry about the details, now, we'll walk through each step below.\r\n\r\n1. Install OpenCV\r\n2. Create a directory that will house your project and its images\r\n3. Acquire or develop positive images\r\n4. Create an annotation file with the paths to your objects in the positive images\r\n5. Create a `.vec` file that contains images of your objects in binary format using the annotation file above\r\n6. Develop and acquire negative images that do not contain the object you wish to detect\r\n7. Train the cascade\r\n8. Test your cascade.xml file\r\n\r\n## Installing OpenCV on Linux/Ubuntu\r\n\r\nI mentioned that the training can take a long time.  It can actually take weeks, I've read.  I **strongly** recommend you use a remote server to train your cascade.  Here are two reason why: one, it will speed up the training immensely (mine took only 18 minutes); and two, installing OpenCV on Ubuntu is way faster than compiling from source on a Mac.  There are no pre-compiled binaries available for OS X.\r\n\r\nI used an 8-core Digital Ocean server to train mine.  This server cost about $5 per day.  You should only need one for a few hours, or perhaps a few days if you struggle to get the training right.  I believe when you sign up for Digital Ocean that you get $10 in credit too, so you can probably do this for free.\r\n\r\nTip: It’s not super difficult to find $10 coupons for Digital Ocean if you look around a bit.  Another benefit of using Digital Ocean for this is that your local machine mustn’t be devoted to the training - a remote server will keep training even if you accidentally close your machine.\r\n\r\n## How to Rent a Digital Ocean server\r\n\r\n1. [Create a droplet on Digital Ocean](https://m.do.co/c/caa99089d223)\r\n2. Choose Ubuntu 14.04\r\n3. Choose a region (region and latency don’t matter here since we only need to download our final cascade.xml file)\r\n4. Ignore the additional options\r\n5. For the SSH key, if you know what this and already have a key on your machine, you can add your public key to Digital Ocean, which is what I recommend. Otherwise please [this brief tutorial](https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets) tutorial to setup SSH keys.\r\n6. Once you have the server up and running and you're logged in, see [this tutorial](https://help.ubuntu.com/community/OpenCV) to install OpenCV.\r\n\r\n## How to Develop a Positive Image Set\r\n\r\nThere are a few ways to develop positives.\r\n\r\n1. Take pictures of the actual objects you intend to detect.  You will have to do this if you're detecting something unique which is not easily google-able.\r\n2. Google your object and save those images.\r\n\r\nI used a combination of these two approaches.\r\n\r\n### Taking Your Own Photos\r\n\r\nHere are a few things to remember when taking pictures of your object(s).  Probably the most important: you can take multiple images of the same thing that count as multiple positives.  You can slightly (but not too much) tilt and rotate  your object (approximately 10-20º).  If you have multiple instances of the object, like shoes, take pictures of all of them, positioned in the same way (toes facing left or right).\r\n\r\n### Googling for Images of Your Object\r\n\r\nI found different color outlets when googling; also different backgrounds and angles.  When googling for your object, you can specify the size of the images Google returns, too.  \r\n\r\nTo set the size once you have clicked \"Images\", \r\n\r\n* Click **“Search Tools”**\r\n* Then **\"Size\"**\r\n* Click **“Size”**\r\n* Click **“Exactly”**\r\n* Enter a size.  I used 256x256 pixels.  I think this is a reasonable balance between maintaining resolution and using small enough images so as to minimize training time.  I tried smaller images, 80x80 pixels which resulted in tons of false positives.\r\n\r\nI recommend using at least 100-200 positives to start off.  You may get a decent result with fewer, some have.  I used ~380 for my final, nearly perfect cascade file, with zero false positives that more than flickered on the screen.\r\n\r\n### Resizing Your Images\r\n\r\nThere is a very handy tool that will easily allow you to shrink all images in a directory: ImageMagick's [Mogrify](http://www.imagemagick.org/script/mogrify.php) tool.\r\n\r\nOnce you have that installed, here's how to resize all `.jpg`s in a directory:\r\n\r\n(this may overwrite your files, make a copy of them first)\r\n\r\n`mogrify -resize 256x256 *.jpg`\r\n\r\nYou can also reformat your images with:\r\n\r\n`mogrify -format jpg *.png` or `mogrify -format jpg *.JPG`\r\n\r\nThose commands will convert the `png`s or rename the `JPG`s to `jpg`s.\r\n\r\n\r\n## Creating an Annotations File with OpenCV’s Annotation Tool\r\n\r\nOnce you have your positive images, you **should** make an annotations file.  I say \"should\" because I think this is an important step.  I didn't generate a working `cascade.xml` file until I used this tool to create an `annotations` file.  At first it seems like this tool will take a long time to make such a file, but it doesn’t.  I suggest starting out by using this tool and not trying to train your cascade without it. \r\n\r\n### Here’s how it works:\r\n\r\nAlong with OpenCV's `traincascade` and `createsamples` applications, when you type `opencv_[tab]` in your terminal (once you have OpenCV installed), you will find another tool: \r\n`opencv_annotation`\r\n\r\nThe `opencv_annotation` tool helps you to quickly generate an annotation file with paths to your positive images and the location and size of the objects within those positive images.  When done, the file will look something like this:\r\n\r\n![annotation file](images/annotation-file.png)\r\n\r\nThe “2” after the file path is the number of positives in each image (lots of mine were two because outlets come in pairs).  Then we have the top left hand corner starting pixel of our object.  Next are the sizes of each object within the image.  \r\n\r\nSo in the first line in the annotations image above, the “230 169” is the pixel at the top left corner in `GOPR4620.JPG` where an outlet starts.  It is 33x40 pixels.  You get the point.\r\n\r\nThe annotation tool writes the paths that you outline in each image for you which saves us a ton of time.  \r\n\r\nHere’s the command that I used to create the annotations file.  \r\n\r\n`opencv_annotation -images . -annotations annotations.txt`\r\n\r\nI had one problem with this tool that will hopefully not happen to you or be fixed.  The annotation tool would not write to the file when “n” was pressed after outlining an object.  It would only write to the file when all of the images in the directory had been processed.  \r\n\r\nAs a workaround, I moved my images into a series of directories and added each directory’s annotations file to the main one using a command like the following, which takes the contents of one file and adds those to another.\r\n\r\n`cat ./sub-dir/annotations.txt >> ./main-annotations.txt`\r\n\r\nBe sure to use two arrows, like “`>>`” or else cat will overwrite your annotations file and you’ll have to start over!\r\n\r\nAfter you create this annotations file you can use the opencv_createsamples tool to create a .vec file but with more varied positive images.\r\n\r\n## Ideal Positive and Negative Images\r\n\r\nIdeally your positive and negative images will contain the actual objects you’re trying to detect in their natural environment.\r\n\r\n## How Can I Develop a Negative Image Set?\r\n\r\nThere are a few ways to generate negative images.  One thing to remember is that you will get the best results when using negatives from the environment you intend to use your cascade file in.  \r\n\r\nIn this post's repository is a directory with \r\n\r\n\r\nIdentify the environment your object detection will be working in: warehouse, home, office, outside?\r\nFind a Youtube.com video that contains your environment.  This should be really easy, Youtube has millions if not billions of videos.\r\nScan the video to make sure it doesn’t contain your desired object.  This may seem like it will take a long time to do.  It doesn’t.  Just start the video and click right every few seconds through it.  You’ll be done in no time.\r\nFind a site that will enable you to download the Youtube video.  This should be easy.  I will leave you to do that yourself.  \r\nDownload that video to a project directory.  I downloaded it to a negatives directory.\r\nSplit the video into images!  This will enable you to create hundreds or thousands of negative images in a few minutes.  I used ffmpeg on my Mac.  You can decide what percent of the video’s frames you would like to keep depending on how many negatives you think you need.d\r\nRepeat this a few times until you have thousands of negatives.  Remember, the more the better your object detection will work.  I didn’t start getting detection results (and not tons of false positives) until I used ~3,500 negatives.  \r\n\r\n## Getting your Image Sets to the Remote Server\r\n\r\nHere are a couple of commands you can use to easily copy your positive and negative images to the remote server.\r\n\r\nFirst, I suggest creating a tarball for each type of image.  This will speed up and simplify the transfer process.\r\n\r\nWhile in your image directories do something like this:\r\n\r\n`tar -cvzf positives.tar.gz /path/to/positives-folder/*.jpg`\r\n\r\n`tar -cvzf negatives.tar.gz /path/to/negatives-folder/*.jpg`\r\n\r\nThese will each create a single file that contains your positive and negative images (with only the file extension you specify at the end) in the path you specified as the last argument above.  \r\n\r\nHere’s the command to copy your tarball to your remote server.  This `ssh`s into your remote server and copies the file to the path you specify:\r\n\r\n`scp positives.tar.gz root@[your-remote-ip]:/remote-project-dir/positive-image-dir`\r\n\r\nTo find [your-remote-ip], just go to this link and look for IP address.  Don’t forget the “`:`” in the command above.\r\n\r\nOnce you've connected to your remote server, while in the appropriate directories, unzip your tarballs: \r\n\r\n`tar -xvf negatives.tar.gz`\r\n\r\n## What Size Should My Images Be?\r\n\r\nSome people use consistently sized images.  I didn't.  One important thing is that the sizes of your images need to be at least the size of the test, which defaults to 24x24 pixels.  \r\n\r\nAccording to an OpenCV author, Steven Putteman, he never uses images with dimensions larger than 80px.  I tried using 80px dimensions to speed things up.  But, I believe much of the image information was lost.  I ended up using 512x512 pixel images.  Smaller images may work, but 512 pixels square worked for me.  \r\n\r\nNote that if your images are small to begin with, increasing their size will not necessarily magically make them readable by the algorithm.  I used this resize for images that started off larger than this, to increase the training speed.\r\n\r\n\r\nWhat definitely does matter is the width (-w) and height (-h) arguments you pass to the `create_samples` and `train_cascade` functions.  You will not be able to detect objects smaller than the dimensions you pass.  \r\n\r\n\r\n### `opencv_traincascade` Parameters\r\n\r\n`opencv_traincascade -numPos 1200 -numNeg -featureType LBP -\r\n* -featureType I would use LPB.  It is faster than HAAR and can result in awesome object detection.\r\n* -w and -h\r\n  * These specify the size of the window the algorithm will apply to the negatives.  Do not specify these dimensions smaller than the object will appear in your working images\r\n* -numPos\r\n  * This one has some gotchas.  You must actually pass a smaller number than the actual number of positives you have.  *You should use 85% as many positives as are actually in the `.vec` file*.  This is because the training algorithm may discard some positives if some are too similar.  If you use `create_samples` to create a `.vec` file, you are more likely to run into this problem.\r\n\r\n## Testing the Performance of Your Cascade File\r\n\r\nWe need to quickly test the performance of our cascade files. \r\n\r\nIncluded in this project's repo, there is a [Python file](https://github.com/JohnAllen/opencv-object-detection-tutorial/test/webcam.py) that you can use to test your object detection locally.  I'd like to credit Shantnu for [originally posting](https://github.com/shantnu/Webcam-Face-Detect) a file very similar to the one included. This file will let you quickly test your cascade file - everyone has Python already.  To test your output cascade file, just run this command:\r\n\r\n`python webcam.py cascade-file-path.xml`\r\n\r\nWhat this file does is run OpenCV's detection in your computer's webcam, so this will only work if you have one of your objects handy.  Sometimes images of objects on your phone or perhaps a printed image will work too.  \r\n\r\nShantnu [wrote a post](https://realpython.com/blog/python/face-detection-in-python-using-a-webcam/) about this file and explains what's going on inside.  I recommend you take a minute to understand it.  \r\n\r\nBut let's take just a minute to look at the OpenCV function that's really doing the work here:\r\n\r\n<script src=\"https://gist.github.com/JohnAllen/399f11f9cbb43db9ce0a234aba7ebdd7.js\"></script>\r\n\r\nIncluded with OpenCV are a [few working cascade.xml files](https://github.com/Itseez/opencv/tree/master/data/haarcascades) too.  It's fun to run things just to see them work, so check those out.\r\n\r\nThat script allows you to use your webcam to test your object.  Using so will obviously necessitate having an image or physical version of your object with you, so it won’t work if you’re trying to detect elephants.  But you could print an elephant.  A phone may work but mine had tons of glare which may falsely reduce your cascade file’s object detection potential.  \r\n\r\nRunning that script successfully with our own webcam helps us know that everything is working correctly, except for our cascade file we are making.\r\nObject Detection Performance\r\n\r\nHow small can my objects be in the image and still be detected?\r\n\r\nThis depends on how small your samples are in your .vec file.  I set mine at 20px x 20px because I want my robot to detect outlets from a long ways away.  Your situation may be different.\r\nWhat does the traincascade output mean?\r\n\r\nWhen training our cascade, we get quite a bit of logging output.  It wasn’t clear to me what it means.\r\n\r\nHere’s an example:\r\n\r\n\r\n\r\nGeneral Tips\r\n\r\nUse an image format that doesn’t lose information compression as much.  This will avoid compression artifacts.  “This is especially the case when resizing your training data.” http://answers.opencv.org/question/39160/opencv_traincascade-parameters-explanation-image-sizes-etc/\r\nImageMagick is your friend.  ImageMagick, which is easily installable with the HomeBrew package manager makes some image operations super easy.  Want to resize some large positive or negative images you took on your smartphone (modern iPhones are 12MP, 3000px * 4000px) which slows down the training algorithm without adding detection capabilities. \r\nThere is not necessarily a correct ratio of positives to negatives.  It all depends on your object and application.\r\nToo many false alarms or false positives\r\n\r\nAdd more information!  Increase your positive and negative image sets.  Your classifier does not have enough information to correctly determine that your object is not in your test images.  When I increased my positives and negatives when I had too many false positives, their number immediately declined and I started getting more stages.  \r\n\r\nError Messages\r\n\r\nHere are the likely causes of various error messages.\r\n“Required leaf false alarm rate achieved. Branch training terminated“\r\n\r\nThe training algorithm can run out of information that will help it to add to its classifiers.  If it has already analyzed the positive and negative images as much as it can, it simply stops.  And this is the output you will get when this happens.  \r\n\r\nThis will happen earlier when you are using smaller image set sizes.  If you only pass it a few dozen or hundred images it can only train a few stages.  The more images you pass, the later you will run into this error and the better the cascade file will do to detect your objects. \r\n\r\nBut maybe your object is super static and it doesn’t take many positives to develop a good classifier.  What you can do is to add the argument -numStages n-1, to opencv_traincascade where n is the stage number it gave you that error message.  This will cause a cascade.xml file to be made that may work, or could at least provide you with some information about whether your arguments and images are on track.  \r\n\r\n# Training Times\r\n\r\nDespite what some have said on the Internet, training times are not always super long.  Mine have been nothing like weeks.  As I write this, I am on the 13th stage using 2700 positives (in a .vec file) and 3500 negatives.  I’m using a dual core Digital Ocean server.  I also passed -numThreads 300 which seems to speed things up substantially.  Only a total of 750MB of ram are being consumed on this two core DO server but hundreds of processes are being run (not sure if passing extra threads also causes additional processes to be run, but I suspect that is the case). \r\n\r\nIf you generate a .vec with only a few dozen or hundreds positives and also use a few hundred negatives, using the setup I am using, with the machine solely devoted to training this cascade, training should only take a few minutes.  At least that’s how it was for me.  \r\n\r\nAnother note about training duration.  When I was using my local machine I was seeing zero progress for multiple days.  I do not believe this should ever occur.  You should be able to see the NEG current samples: 123 line increment slowly.  This is how you can know yours is making progress.  \r\n\r\nNote that each stage’s training times get longer; exponentially so.  ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}